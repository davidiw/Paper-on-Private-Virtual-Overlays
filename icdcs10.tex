\documentclass[conference]{IEEEtran}
\usepackage[dvips]{graphicx}
\graphicspath{{figs/}}
%\DeclareGraphicsExtensions{.eps}
\usepackage[cmex10]{amsmath}
%\interdisplaylinepenalty=2500
%\usepackage[tight,footnotesize]{subfigure}
%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
%\usepackage[caption=false,font=footnotesize]{subfig}
%\usepackage{fixltx2e}
%\usepackage{stfloats}
\usepackage{url}
\hyphenation{op-tical net-works semi-conduc-tor}

\usepackage{multirow}
\usepackage{array}
\usepackage{footnote}

%\widowpenalty=1000
%\clubpenalty=10000

\begin{document}
\title{Virtual Private Overlays: Secure Group Communication over Decentralized
Public Overlays in NAT-Constrained Environments}

\author{\IEEEauthorblockN{David Isaac Wolinsky, Kyungyong Lee, Tae Woong Choi, P. Oscar Boykin, and Renato Figueiredo} 
\IEEEauthorblockA{Advanced Computing Information Systems Lab\\
University of Florida}
}

\maketitle

\begin{abstract}
Structured P2P overlays provide a framework for building distributed applications that
are self-configuring, scalable, and resilient to node failures.  Such systems
have been successfully adopted in large-scale Internet services such as content
delivery networks and file sharing; however, widespread adoption in small/medium
scales has been limited due in part to security concerns and difficulty
bootstrapping in NAT-constrained environments.  Nonetheless, P2P systems can be designed to
provide guaranteed look-up times, NAT traversal, point-to-point overlay
security, and a distributed data store. In this paper we propose
a novel way of creating overlays that are both secure and
private and can be bootstrapped from a public overlay.
Private overlay nodes use the public overlay's distributed data store to discover
each other, and the public overlay's connections to assist with NAT hole punching
and as relays providing STUN and TURN NAT traversal techniques.  The security
framework utilizes groups, which are created and managed by users through
a web interface that can be hosted on the Internet.
Each group acts as a Public Key Infrastructure (PKI) relying on
the use of a centrally-managed web site providing an automated Certificate
Authority (CA).  We present a reference implementation which has been used in
a P2P VPN (Virtual Private Network).  Additionally, we evaluate our contributions using
both the P2P VPN in the PlanetLab wide-area testbed as well as with event-driven
simulations of the overlay using simulated time delays.
\end{abstract}
\section{Introduction}
While Structured P2P overlays provide a scalable, resilient, and self-managing
platform for distributed applications, their adoption rate has been slow outside
data distribution services such as BitTorrent
and eDonkey.  General use of structured P2P systems, especially in applications
targeting home and small/medium businesses (SMBs), has been limited in large
part due to the difficult nature of securing such systems to the level required
by these users.  Applications in home
and SMBs may need a greater level of trust than what can be guaranteed by
anonymous contributors in free-to-join overlays, but these users lack the
resources for bootstrapping private P2P overlays particularly in constrained
wide-area network environments where a significant amount of or all
peers are behind Network Address Translation devices (NAT). This paper presents
a novel approach that enables virtual private overlays 
to be created and managed by members of small/medium groups, leveraging public
overlays for bootstrapping, NAT traversal and relaying.

There are many different P2P applications used in home and small business,
primarily for collaboration and sharing, including data storage, media
sharing, chat, and system maintenance and monitoring.
Applications that currently provide these functionalities fall into two
categories:  anonymous, fully decentralized free-to-join P2P systems and
distributed systems with P2P communication that rely on a third party to provide
discovery and management.  While using a third party service provides a desirable
level of trust for many users, it has significant drawbacks such as vendor lock-in,
which may result in lost data, down time, and scalability constraints.

An example of a useful small business application that falls into the latter
category is LogMeIn's~\cite{logmein} software products LogMeIn Pro and Hamachi.
LogMeIn Pro allows users to remotely manage and connect with their machines so
long as they are willing to use LogMeIn's software and infrastructure.  Hamachi
allows users to establish decentralized VPN links using centralized session
management.  Both applications assist in the remote maintenance and monitoring
of computers without requiring the user to implement the networking
infrastructure provided by LogMeIn.

Some examples of P2P applications for homes and small
businesses in development are P2PSIP and P2Pns.  P2PSIP enables users to initiate, through decentralized means, visual
and audio communication, while P2Pns allows users to deploy a decentralized
naming service.  Both applications allow users to contribute and benefit from
all members of the system without the regulation of a third party, but lack the
ability to allow users to centrally secure and manage their own subset of the
systems.

Distributed data store applications like Dynamo~\cite{dynamo} and
BigTable~\cite{bigtable} have the ability to store data using a completely
decentralized system.  Though these systems are highly scalable and fault
tolerant, the software uses an untrusted overlay.  Therefore all instances
need to run in a secure environment, whether that be in a single institution
or across a largely distributed environment using a VPN.

In this paper, we describe the architecture of a system that attempts
to balance the benefits of third party services with P2P infrastructures.
Two main contributions of this paper are the architecture of a P2P messaging
framework that integrates existing datagram-based security and supports
bootstrapping multiple virtual private overlays that efficiently multiplex a
peer's network resources subject to constraints such as NATs.
Our system relies on a completely open infrastructure using mechanisms that
reduce the maintenance and deployment burden that exist with decentralized
P2P systems without the loss of ownership due to use of third party systems.
The components of our system follow:
\begin{enumerate}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\item An application layer security system based upon an existing datagram-based
transport security (DTLS) framework to provide secure end-to-end (EtE) and
point-to-point (PtP) in P2P overlays\footnote{For our discussion a point-to-point
or PtP relationship refers to direct connections between two peers, such as a UDP
or TCP socket; whereas, an end-to-end or EtE relationship refers to messages passed
through the overlay, which may be routed over many PtP links.}
 while transparently handling security
concerns of relay NAT traversal.
\item The bootstrapping of private P2P overlays using existing public overlays.
The term "public overlay" refers to a free-to-join bootstrap overlay; nodes in
the public overlay are not required to have public IP addresses and can be
behind NATs.
\item A group web interface providing an automated front-end handler for a 
Public Key Infrastructure (PKI) that allows users to create their own secure
systems relying on P2P overlays.
\end{enumerate}

Our approach provides an easy mechanism to create trusted overlays in
constrained environments using a publicly available untrusted overlay as
illustrated in Figure~\ref{fig:subrings}.  Akin to other virtualization
techniques, the virtual private overlay model allows developers to focus
on the application, while complexities associated with enforcing isolation
and security and messaging are abstracted away.
This approach also has benefits for system deployers, whereas insecure systems
would require modifying the overlay software to support security, application
level security, or the deployment of a decentralized and scalable VPN in
addition to the overlay software.

\begin{figure}[h]
\centering
\includegraphics[width=3.25in]{subrings.eps}
\caption{The use of a single, public overlay to bootstrap multiple, isolated
private overlays.  The center pool is the public pool.  Each node in the
private pools has a corresponding partner in the public pool, the relationship
is represented by a dashed line.  A public overlay node can be multiplexed by
more than one private overlay.}
\label{fig:subrings}
\end{figure}

The rest of this paper is organized as follows.  Section~\ref{structured_p2p}
provides background and related work.
Section~\ref{contributions} describes our contributions.  In
Section~\ref{applications}, we present different usage models and present a
real system using the techniques described in this paper, the GroupVPN.  In
Section~\ref{evaluations}, we use both real and simulated systems to provide
further understanding of the approach.  We conclude the paper in
Section~\ref{conclusions}.

\section{Background}
\label{background}
In this section, we begin by reviewing structured P2P overlays, followed by
constraints that make the creation of secure and private P2P overlays
difficult, and related work.

\subsection{Structured P2P Systems}
\label{structured_p2p}
Structured P2P systems provide distributed look up services with guaranteed
search time in $O(\log N)$ to $O(\log_2 N)$ time, in contrast to unstructured
systems, which rely on global knowledge/broadcasts, or stochastic techniques
such as random walks~\cite{unstructured_v_structured}.  Some examples of
structured systems can be found in~\cite{pastry, chord, symphony, kademlia,
can}.  In general, structured systems are able to make these guarantees by
self-organizing a structured topology, such as a 2D ring or a hypercube.

The node ID, drawn from a large address space, must be unique to each peer,
otherwise an address collision occurs which can prevent nodes from participating
in the overlay.  Furthermore, having the node IDs well distributed assist in
providing better scalability as many algorithms for selection of shortcuts
depend on having node IDs uniformly distributed across the entire address space.
A simple mechanism to ensure this is to have each node use a cryptographically
strong random number generator.  Another mechanism for distributing node IDs
involves the use of a trusted third party to generate node IDs and
cryptographically sign them~\cite{secure_routing}.

As with unstructured P2P systems, in order for an incoming node to connect with
the system it must know of at least one active participant.  A list of nodes
that are running on public addresses should be maintained and distributed with
the application, available through some out-of-band mechanism, or possibly using
multicast to find pools~\cite{pastry}.

Depending on the protocol, a node must be connected to closest
neighbors; optimizations for fault tolerance suggest
that it should be between 2 to $\log(N)$ on both sides.  
%If a peer does not
%know the address of its immediate predecessor or successor and a message
%is routed through it destined for them, depending on the message type, it may
%either be locally consumed or thrown away, never arriving at its appropriate
%destination.  Thus 
Having multiple peers on both sides assist in stabilizing the overlay structure
when experiencing churn, particularly when peers leave without warning.

Overlay shortcuts enable efficient routing in ring-structured P2P systems.  The
different shortcut selection methods include: maintaining large tables without
using connections and only verifying usability when routing
messages~\cite{pastry, kademlia}, maintaining a connection with a peer every
set distance in the P2P address space~\cite{chord}, or using locations drawn
from a harmonic distribution in the node address space~\cite{symphony}.

Most structured P2P overlays support decentralized storage/lookup of information by
mapping keys to specific node IDs in an overlay.  At a minimum, the data is stored
at the node ID either smaller or larger to the data's node ID and for fault
tolerance the data can be stored at other nodes nearby.  This sort of mapping
and data storage is called a distributed hash table (DHT) and is a typical
component of most structured P2P systems.

\subsection{Constraints in Structured P2P Systems}
\subsubsection{Communication Between Nodes}
There are two mechanisms for message routing in a P2P overlay: iterative or
recursive.  In iterative routing, the sender of a packet will contact each
successive member in a path directly until it find the destination node, at
which point it sends the packet directly to the destination.  In recursive
routing, messages are sent through the overlay via forwarding from one peer to
the next until arriving at the destination.  Iterative routing can easily be
secured using stream and datagram based security such as TLS~\cite{tls} and
DTLS~\cite{dtls}, because the sender initiates all messages.  In contrast, in
recursive routing, EtE communication cannot be secured in the same fashion by
through socket-based TLS and DTLS, the sender because messages are routed
through intermediate nodes.

\subsubsection{Private and Secure Overlay Subsets}
While EtE authentication and privacy is key for many applications, it does not increase the reliability of the structured
overlay.  In a free-to-join system, malicious peers can easily intercept packets
for eavesdropping, discard or tamper them.  To deal with
this issue, each overlay node could participate with a subset of other nodes in
a secure system where each peer would maintain a routing table containing a subset
of those involved.  Each node would have to distinguish between the different
messages, handing them to unique routers for each group, handle connectivity
of the subset during churn, and providing a distributed data store for use by this subset.
Achieving this functionality can require substantial modifications to the core overlay
messaging and storage primitives. In this paper we advocate a virtualization approach
that multiplexes private overlays that provide the same abstraction of the underlying
public overlay, and thus can reuse core overlay primitives without modifications.

\subsubsection{NATs}
Another key issue faced by P2P systems is the handling of NATs.
A recent study~\cite{p2p_nats} has shown that 30\%-40\% of nodes in P2P systems
are behind NATs.  In environments where there are NATs, iterative routing can be
significantly more difficult to deploy, since each message sent may require
multiple NAT traversals.  There are a few types of NATs that can be traversed
to support bidirectional communication through UDP-hole punching, known as STUN.
The remaining categories of NATs either do not support UDP-hole punching due to
how the NATs do port mapping or support only TCP communication and block all
UDP communication.  In~\cite{tcp_nat}, the authors evaluated many common NAT
boxes and determined that STUN works on approximately 70\% of NAT devices.
Unlike UDP hole punching, most TCP techniques require either super-user access
or be configured with external software packages that require super-user access.
While the remaining device require an intermediary or relay to pass packets
between the peers behind the NATs.  Though relays or TURN style NAT traversal
presents issues similar to EtE communication in recursive routing, namely, each
node will authenticate itself with the relay, but they will not readily be
able to authenticate each other using socket-based TLS or DTLS.

\subsection{Related Works}
BitTorrent~\cite{bittorrent_security}, a P2P data sharing service,  supports
stream encryption between peers sharing files.  The purpose of BitTorrent
security is not to keep messages private but to obfuscate packets to
prevent traffic shaping due packet sniffing. Thus BitTorrent security uses a
weak stream cipher, RC4, and lacks peer authentication as symmetric keys are
exchanged through an unauthenticated Diffie-Hellman process.

Hamachi~\cite{hamachi} provides central group management and a security
infrastructure through a Web interface.  Their security system has gone through
two revisions as documented in~\cite{hamachi_security}.  Initially peers learn
of each other through Hamachi's central system, which leads to the creation of
secure links.  In their original approach, they use a system similar to a Key
Distribution Center (KDC), which requires that all security sessions initiate
through Hamachi's central servers.  In the latest version, this model has been
retained but with the addition of an external PKI, which avoids the
man-in-the-middle attack but with has the additional cost of maintaining both
an external CA and certificate revocation list (CRL).  Hamachi also supports
STUN, or NAT hole punching, and TURN style NAT traversal, though TURN requires the use of
Hamachi's own relay servers.  Because Hamachi is closed, it disables users from
hosting their own infrastructures including session management and relay
servers.

Skype~\cite{skype}, like P2PSIP, allows for decentralized audio and video
communication. Unlike P2PSIP, Skype is well-established and has millions
of users and is also closed.  While Skype does not provide documentation
detailing the security of its system, researchers~\cite{skype_auth,
skype_overview} have discovered that Skype supports both EtE and PtP security.
Though similar to Hamachi, Skype uses a KDC and does not let users setup their
own systems.

The RobotCA~\cite{robotca} provides an automated approach for decentralized
PKI.  A RobotCAs receives request via e-mail, verifies that the sender's e-mail
address and embedded PGP key match, signs the request, and mails it back to the
sender.  RobotCAs are only as secure as the underlying e-mail infrastructure
and provide no guarantees about the person beyond their ownership of an e-mail
address.  A RobotCA does not provide features to limit the signing of
certificates nor does it provide user-friendly or intuitive mechanisms for
certificate revocation.

Three approaches that propose a public overlay to create sub-overlays are
\cite{one_ring}, \cite{randpeer}, and \cite{can_multicast}.
The approach described in~\cite{one_ring} proposes the use of a universal
overlay as a discovery plane for
service overlay.  The argument is that a participant of an overlay
must support all services provided by that overlay such as multicast, DHT,
or distributed search.  Our work has the same foundations as this paper, but
takes the idea further by using the universal overlay for NAT traversal
additionally we provide mechanisms for applying PKI techniques for PtP and EtE
messaging in the service overlays.
Similarly, Randpeer~\cite{randpeer} uses a common overlay along with a
subnetting service to create individual networks for applications and services,
though the project has seen little activity and lacks implementation details.
Unlike the previous two, \cite{can_multicast} limits the sub-overlay for the
purpose of establishing multicast groups, though their approach lacks discussion
on how nodes discover and form a new overlay as such their approach is limited
to simulations.

Distributed data store applications like~\cite{dynamo, bigtable} require that
all machines have symmetric connectivity additionally like~\cite{past}, suggesting
the use of a third party application to ensure trust amongst all overlay
participants.  This is an example use case that is explicitly targeted by our
system on the presumption that there are not sufficiently easy to use
decentralized VPN software applications~\cite{sc09, nsdi10} and even if there
were it is undesirable to have additional setup requirements.

While there has been much research~\cite{secure_routing} in securing overlays
through decentralized mechanisms that attempt to prevent a collusion known as
a Sybil attack~\cite{sybil}, these mechanisms do not create private overlays.
While one approach mentioned does provide a natural lead into such
environments, which is the use of a pay-to-use service to mitigate the chances
of an overlay attack, whereby the pay to use service uses a CA to sign node
IDs.  The work does not describe how to efficiently implement such a system.
Other similar research attempts to create trusted systems~\cite{stone, tor} but
with anonymous members, though it could be reasonably argued these services are
not applicable to small or medium business, which would prefer to have a private
overlay.  None of the works discuss how to apply such models to
systems that are constrained in network connectivity, e.g by NATs.

\section{Bootstrapping Secure and Private Overlays}
\label{contributions}
In this section, we explain the individual components of our contribution.  We
begin by describing the application of SSL-derived protocols for EtE and PtP security in
overlays, which leads to a discussion on the use of a group web interface to
provide a user-friendly PKI, and concludes with our approach to bootstrapping
private and secure overlays in constrained environments using public overlays.

\subsection{Secure Overlays}
\label{secure_overlays}
Securing EtE and PtP communication in overlays using iterative routing with
servers using static IP addresses can easily be done using TLS or DTLS with
certificates bound to the servers static IP address.  This approach does not
port well to systems that use recursive routing. First, TLS cannot easily be used
because overlay routing in NAT-constrained environments is traditionally done through datagrams and not streams,
which would require overlays to implement a reliable stream to use TLS. 
DTLS can be applied because it supports lost and out of order messages, though
the implementation must support usage without a socket.  The
problem then becomes how to deal with identity.  In this section, we discuss how
to bind security protocols and a certificate model to an overlay system.

The key to our approach is abstracting the communication layer, making EtE and
PtP traffic appear identical. In this approach, all messages are datagrams that are sent
over abstracted senders and receivers as filters illustrated in
Figure~\ref{fig:senders_receivers}.  This allows us to use secure tunnels over
these links with no application changes.

\begin{figure}[h]
\centering
\includegraphics[width=3.25in]{secure_sender_stack_generic.png.eps}
\caption{An example of the abstraction of senders and receivers using a EtE 
secured chat application.  Each receiver and sender use the same abstracted
model and thus the chat application requires only high-level changes, such
as verifying the certificate used is Alice's and Bob's, to support security.}
\label{fig:senders_receivers}
\end{figure}

Exchanged certificates need a mechanism to verify authenticity.  Like an
Internet browser, this verification should happen automatically with no user
intervention.  Typically for TLS and DTLS, the certificates have the Web site's
IP address or domain name as part of the certificate's common name field.  In
our system, we bind the certificate to each individual node ID.  That way,
a single certificate cannot be used for multiple peers in the overlay, making
it difficult for an adversary to launch Sybil attacks.

\subsubsection{Forming the Connection}
In overlay systems, a peer's connection manager requests to make an outgoing
connection to another peer in the system.  This triggers the creation of a
socket (UDP or TCP), which is wrapped in the abstracted sender and receiver
models.  The abstracted models arrive into the security handler, which
authenticates in both directions and creates a secure session.  The session is
wrapped in the same abstracted model and presented to the overlay system as a
direct connection to the remote peer.  To keep the system abstract, the security
model and the wrapped sockets know nothing about the overlay, and so the overlay
should verify the certificate to ensure identity.

Because EtE communication is application-specific, it requires
a slightly different path.  For that purpose, we have a specific module that
allows an application to request a secure EtE sender; the application needs to be prepared to deal with the
process of handling verification.  Once an application requests the sender, the
module passes a sender / receiver model to the security handler, like in the PtP
process.  Once the security initialization has completed, the
resulting sender / receiver is verified automatically for proper identity.
If that succeeds, messages sent using the EtE sender will arrive at the remote
party, decrypted and authenticated by the security handler, and delivered to the
overlay application, who will deliver to the remote party's handler for such messages.
Since overlay application will be sending and receiving
unencrypted as well as encrypted EtE traffic, the handler must verify that the
packet was sent from a secure end point.  This assumes that an application using
an overlay has already implemented verification of node ID to some application
mapping.  For example, an application could be aware that node ID X maps to user
Y, therefore if a secure message coming from node ID Z says that it is user Y,
an application should drop the packet.

\subsubsection{Datagram Constraints}
Since UDP is connectionless, applications that use it can easily be victims of
denial of service attacks.  This is because packets sent to the receiver can
have a spoofed source address, unless the outgoing gateway prevents this from
occurring.  Whereas with TCP, it would be significantly harder to perform the
same attack unless performed as a man-in-the-middle.  To reduce the potential
of these spoofing attacks prior to establishing a secure connection, DTLS (like
Photuris~\cite{photuris}) uses a stateless cookie for each remote peer.  In
DTLS, the cookie is usually based upon the remote peer's IP and the current
time.  In our model, which deals with abstracted systems and IP addresses are
likely to be NAT-translated, this approach does not work.  Because we are
building on existing senders and receivers that already have state, we use the
object's memory pointer or hash value instead.  Though this leads us down a
similar path of denial of service, it does so at a much slower rate.

\subsection{Private Overlays}
The main components involved in the starting and maintaining a private overlay
are 1) dissemination of the security credentials and its name, 2) connecting
with and storing data in the public overlay, and 3) discovering and connecting
with peers in the private overlay.  Step 1) can be application-specific; we
propose a generic interface that is useful in many applications, through the use of groups as described in Section
Section~\ref{group_overlays}.  For 2), we presume the usage of a structured
overlay as described in Section~\ref{structured_p2p}.  In this section, we
discuss 3), the steps involved in creating and connecting to a private overlay
after the user has obtained group information and has connected to a public
overlay.

To connect with and create a private overlay, the application performs the
following steps: 1) connect to the public overlay; 2) store node ID in the
public overlay's DHT at the private group's key; 3) query the public overlay's
DHT at the private group's key; 4) Start an instance of the private overlay with
the well-known end points being those of the node IDs retrieved from the DHT;
and 5) Upon forming a link with a member in the private overlay, the node follows
the general approach for linking to neighbors and shortcuts but using security
to restrict connections to only members of the private overlay

The node should maintain membership in the public overlay when connected with
the private overlay.  This is needed for two reasons: first, so that other peers can discover the
node while following the same set of steps; and second, for NAT traversal purposes, as
discussed in the next paragraph.  Because the public overlay and its DHT
provides a means for discovery, nodes must maintain their node ID in the public
key's DHT.  A data inserter must constantly update the lease for the data
object, otherwise the data will be removed.  This is because DHTs are
implemented as leasing systems or as soft state, whereby data objects are
inserted with a time to live and removed upon expiration.

During the formation of the private overlay, peers may find that they are
unable to form direct connections with other members of the private overlay
even while using STUN based NAT traversal.  
We propose two solutions to address this problem: 1) to use TURN NAT traversal 
in the nodes overlay as discussed
in~\cite{nsdi10} and 2) use the public overlay as an extra routing massive TURN
infrastructure.  The TURN NAT traversal technique has both peers connect with
each others near neighbors in order to form a 2-hop connection with each other.
The 2-hop route can either be enforced through a static route or through EtE
greedy routing.  Due to the abstractions in the system, the public overlay can
be treated as another mechanism to create PtP links, thus while packets may use
EtE routing on the public overlay the private overlay nodes treat it as a PtP
connection thus all communication is secured.  This approach can be further
enhanced by allowing the private overlay to apply the TURN NAT traversal
technique to the public overlay.  To do this, the private overlay must be
capable of requesting a direct connection between its node and the remote
peer in the public overlay.  This would trigger the eventual creation of a 2-hop
relay connection as presented in Figure~\ref{fig:overlay_relay}.

\begin{figure}[h]
\centering
\includegraphics[width=2.75in]{subring_tunnel.eps}
\caption{Creating relays across the node address space, when direct
connectivity is not possible.  Two members, A and B, desire a direct connection
but are unable to directly connect, perhaps due to NATs or firewalls.  They
exchange private, 1, and public, 2, neighbor information through the private
overlay and connect to one of each other's neighbors, creating an overlap.  The
overlap then becomes a PtP relay path (represented by directed, dashed lines),
improving performance over routing across the entire overlay.}
\label{fig:overlay_relay}
\end{figure}

%Another concern we address is the cost of having to maintain additional
%connections for each additional private overlay.  For this, we propose the use of
%{\em pathing}, which multiplex a single UDP or TCP socket to support multiple
%overlay nodes.  This model is supported because of the abstraction done on
%senders and receivers.  Thus a UDP or TCP connection can be easily wrapped 
%inside an arbitrary packet, in this case, a pathing connection.  Upon sending
%a packet, the message is prepended with path information.  When the remote side
%receives a packet, it parses and removes this pathing information and relays it
%to the appropriate receiver, i.e., overlay node.  We validate this approach in
%Section~\ref{pathing_evaluation}.

When overlays are small and have significant churn, it is easy for data stored
in the overlay's DHT to be lost.  This can be improved by also supporting
broadcast in the private overlay.  In this model, each peer acts as a
storage point for all data critical to itself.  If another peer cannot
successfully find data stored at a specific key in the overlay, it can make
use of broadcast over the entire overlay in an attempt to find
the result.  The technical details of our broadcast implementation are described
at the end of Section~\ref{implementation} and an evaluation of our revocation
approaches can be found in Section~\ref{evaluation_revocation}.

During our evaluation, we discovered that in certain cases the private overlay
would not form a proper well-formed state but rather more than one distinct or
partitioned overlays creating a fragmented overlay.  The underlying issue was that the
partitioned overlays believed they were in a well-formed state and thus never
reviewed the DHT list to determine if there were peers that should be their
neighbors.  This caused the overlay to remain fragmented until either a new
peer joined or enough peers left causing the nodes to believe they are in a
non-well-formed state and require bootstrapping links or a more proactive 
method.  The reason the issue even existed was that states of significant churn,
especially during a bootstrapping of a significant amount of new nodes in the
system, the DHT list can become unstable with each set of node potentially
seeing different lists.  Of course by the end, the lists would be well-formed,
but at that point, the overlay would have already fragmented.

To proactively solve the fragmentation issue, the node performs the following
steps: 1) continuously query the DHT;  2) upon receiving the DHT query result,
the node determines if there is a peer with whom it should be connected to
such as that it is closer in the address space then any of its current neighbors;
3) form a connection with that peer; and 4) the system should automatically at
this point in time realize the network fragmentation and heal itself.  In our
system, this involved creating a bootstrapping connection with the peer.  Upon
a successful connection, the system automatically causes the networks to heal.

\subsection{Group Overlays}
\label{group_overlays}
To establish trusted links, we use the PKI model, where a centralized CA (for a group) signs
all client certificates and clients can verify each other without CA interaction
by using the CA's public certificate.  However, setting up, deploying, and then
maintaining security credentials can easily become a non-negligible task,
especially for non-experts.  Most PKI-enabled systems require the use of
command-line utilities and setting up your own methods for securely
deploying certificates and policing users.  While this can be applied to an
overlay, our experience with real deployments indicates that usability is very
important, leading us to find a model with easy to user interfaces.
In this section, we present our solution, a partially automated PKI reliant on
a redistributable group based web interface.  Although this does not preclude
other methods of CA interaction, our experience has shown that it provides a
model that is satisfactory for many use cases.

\subsubsection{Joining the Group Overlay}
Membership of an overlay maps a set of users as a group. This led us to the
model of using a group infrastructure as a means to apply a PKI.  Using our
system, a user can host an individual or multiple groups per Web site.  The
creator of the group becomes the default administrator, and users can request
access to the group.  Upon an administrator approving, users are able to
download configuration data containing overlay information and a shared key
used by the overlay application to communicate securely with the web interface.
The shared key uniquely identifies the user to the web site allowing the
application to securely send certificate requests.  By default, the Web site
automatically signs all certificate requests, though it is not limited to this
model.  Two other approaches are 1) require the user to submit a request and
wait for an administrator to verify each request and 2) set a maximum amount
of automatic request signings then requiring administrative approval for more.

As stated in Section~\ref{secure_overlays}, the certificate request is bound
to the application's node ID, which can be generated by the CA or the
application.  Additionally in the group system, the certificate also contains
the user who made the request and the group for which the certificate is valid.
Not only does this ensure that a single certificate can only be used for each
node instance, but it reduces the amount of state necessary to revoke a user
from a system.  Specifically, to revoke a user, the CA would only need to
provide a signed revocation notice containing the user's name and not every one
of the previously signed certificates.

Upon receiving a signed certificate, the overlay application can connect to the
overlay where all PtP traffic will be secured and, optionally, so can EtE
traffic.  It is imperative that any operations that involve the exchanging of
secret information, such as the shared secret, be performed over a secure
transport, such as HTTPS, which can be done with no user intervention.

\subsubsection{Handling User Revocation}
Unlike decentralized systems that use shared secrets, in which the creator of
the overlay becomes powerless to control malicious users, a PKI enables the
creator to effectively remove malicious users.  The methods that we have
incorporated include:  a user revocation list hosted on the group server,
DHT events requesting notification of peer removal from the group, and
broadcasting to the entire P2P system the revocation of the peer.

A user revocation list offers an out-of-band distribution mechanism that can
not easily tampered, whereas communication using the overlay can be hampered
by Sybil attacks.  The revocation list is maintained on the Web site and updated
whenever an administrator removes a user, or a user leaves the group.
Additionally it can be updated periodically so that a user can verify that the revocation
list is up to date.

However, because the user revocation list requires centralization, users should
not query it prior to every communication nor periodically during conversations.
In addition to support for polling the revocation list, the use of the DHT and broadcast provides active notification of
user revocation.  Revocation through the DHT method allows a peer to request
notification if another peer is revoked from the group.  To subscribe for this
notification, the peer inserts its node ID at the peer's revocation
notification key, which we represent as a hash of its node ID.  Upon revocation,
the CA will first insert a revocation notice at this key and then query the
key for all node IDs notifying each of them of the revocation.  The insertion
of the revocation notice handles a race condition, where a peer may insert
its ID but never receive a notification.  Thus after inserting the request for
notification upon revocation, the peer should ensure that a revocation has not
occurred by querying the DHT to verify the CA has not inserted a revocation.

When the group is securing PtP traffic, the DHT approach does not effectively
seal the rogue user from the system until all peers have updated the revocation
list.  A peer may continuously connect to all peers in the system until they
have all queried the DHT key prior to verification.  Due to this issue, we do
not employ this model in the group overlay.  Instead a broadcast will ensure
that all peers in the system do know about the revocation.  The strength of
the DHT approach exists when using a public free-to-join and an application
secured by the group, as in~\cite{nsdi10}.

In Section~\ref{evaluation_revocation}, we present more technical details and
an evaluation with focus on latency and bandwidth of these three methods.  

Because the security framework is based on PKI, another approach that is also
supported is the use of certificate revocation lists
(CRL) found in most CA systems.  The advantage of a CRL and revoking individual
certificates is the ability to remove a subset of a user's node, particularly
useful in the case that the user was not malicious but that some of their nodes
had been tampered or hijacked.

\section{Applications}
\label{applications}
In this section, we present applications and potential ways to configure them
to use a private overlay.  The applications we investigate include instant
message, VPNs, and social networks.  The key to all these applications is that
users can easily host their own services and be discovered through the use of
a NAT-traversing, structured overlay network.

\subsection{Chat Rooms}
Chat rooms provide a platform for individuals with a common interest to find
each other, group discussion, private chat, and data exchange.  One of the most
popular chat systems for the Internet is Internet Relay Chat (IRC).  As
described in~\cite{irc}, IRC supports a distributed tree system, where clients
connect to a server, and servers use a mixture of unicast and multicast to
distribute messages.  The issues with IRC are documented by~\cite{irc_arch},
namely, scalability due to all servers needing global knowledge, reliability due
to connectivity issues between servers, and lack of privacy.  Private overlays
could be extended to support the features of IRC and potentially deal with these
inherent issues.  Each chat room would be mapped to a private overlay and the
public overlay would be used as a directory to learn about available chat rooms
and request access.  Structured overlays do not require global knowledge and can
be configured to handle connectivity issues.  Additionally, IRC by default uses
clear text messaging and even if security is used a server will be aware of the
content of the message, two issues resolved by using PtP security in a private
overlay chat room.  

\subsection{Social Networks}
Social networks such as Facebook and MySpace provide an opportunity for users to
indirectly share information with friends, family, and peers via a profile
containing personal information, status updates, and pictures.
Most social network structures rely on hosted systems, where they become
the keepers of user data, which creates privacy and trust concerns.  Private overlays
can remove this third party, making users the only owner of their data.  For this
model, we propose that each user's profile be represented by a private overlay
and that each of their friends become members of this overlay.  The overlay will
consist of a secured DHT, where only writes made by the overlay owner are valid
and only members of the overlay have access to the content stored in it.  In
addition to bootstrapping the private overlays, the public overlay would be
used as a directory for users to find and befriend each other.  For fault
tolerance and scalability, each user provides a copy of their profile
locally, which will be distributed amongst the private overlay in a read-only
DHT, therefore, allowing the user's profile to be visible whether they are
offline or online.  Each user's social network would than consist of the
accumulation of the individual private overlays and the public overlay.

\subsection{P2P VPNs}
As described in~\cite{nsdi10}, private overlays enable P2P VPNs.  The most
common type of VPNs are centralized VPNs like OpenVPN, which requires that a
centralized set of resources handle session initialization and communication.
Another approach taken by Hamachi and many others is to maintain a central
server for session initialization but allow communication to occur directly
between peers and providing a central relay when NAT traversal fails.  Using
a structured private overlay allows users to host their own VPNs, where each
VPN end points is responsible for its own session initialization and
communication.  The private overlay also provides mechanisms for handling
failed NAT traversal attempts via relaying.

\subsection{Multicast}
The topic of secure multicast has been a focus of much research citations.
Using an approach similar to CAN~\cite{can_multicast}, a private ring can form
a ring where all nodes are members of the multicast group with the additional
feature that you can trust that your audience is limited to those in the
overlay.  The main advantage of such multicasting technologies would be for
wide-area, distributed multicast for the purposes of systems supports different
types of multicast applications such as light weight multicast DNS / DNS-SD
(service discovery) or more heavy weight but fault tolerant like streaming
audio and video.

\section{Implementation Details and Evaluation}
\label{evaluations}
In this section, we describe our prototype implementation of a secure, private
overlay followed by evaluation to quantify network overheads.

\subsection{Our Implementation -- Brunet}
\label{implementation}
Our implementation uses the Brunet~\cite{brunet} library, which is a P2P system
based upon the concepts introduced by Symphony~\cite{symphony}.  Its topology is a
one-dimensional ring, where peers connect with up to the four peers closest
to themselves in both directions in the node ID space.  Shortcuts are based
upon a harmonic distribution and the use of proximity~\cite{hpdc08_0}.  The
system supports distributed versions of STUN or hole-punching and TURN-like or
relay based NAT traversal~\cite{nsdi10}.  The system uses a DHT as a distributed
data store using a replication algorithm that spreads a single key, value pair
throughout the ring as described in~\cite{pcgrid07}.  Additionally, the overlay
has support for autonomic~\cite{wow} and manual creation of single-hop
connections and double-hop through relaying when NATs prevent direct
connections.  Furthermore, we have developed a P2P VPN on top of this stack,
which has been used for over three years to support a ad hoc distributed
grid~\cite{archer, gridappliance}.

The focus of this paper is on security and the bootstrapping of private pools.
In the previous sections, we have abstracted the implementation to generic
overlays, while in this section, we will present our experiences and lessons
learned in applying security protocols to the overlay.  To provide security, we
investigated two approaches:  reusing OpenSSL's DTLS implementation or making
our own platform-independent DTLS using C\# and cryptography routines provided
by .NET.  Because we are sending messages over unreliable mediums such as UDP
sockets, relays, and an overlay, we could not reuse SSL or TLS.  Additionally
we want EtE security for relays and overlay communication, the security needed
to be implemented through a filter or only in memory and not on a socket.

While OpenSSL is a de-facto standard, with US federal government approved code, and 
platform portability, during our use of the platform we experienced several
issues.  The portability provided by OpenSSL is limited to API (Application
Programming Interface) and not ABI (Application Binary Interface), which
requires a platform-specific library be either installed or distributed with
the application.  Whereas the purpose in using C\#, like Java, is that a single
binary can run on any platform.  To use unmanaged libraries from a managed
language requires a marshaling wrapper to handle the translation; there is
such a wrapper for OpenSSL~\cite{openssl.net}.  A constraint we found when
using the library was the naming of the OpenSSL libraries was not consistent
across platforms and, additionally, Windows lacked a formal installation method.
%In using the OpenSSL library with DTLS, in version 0.9.8k, renegotiation of
%security parameters  was broken and would result in a deadlocked DTLS session,
%whereas in 1.0.0-beta3 (the latest released beta) DTLS renegotiation worked;
%however, it would often segmentation fault.

%The handshake used is shown in Figure~\ref{fig:dtls}.

%\begin{figure}[h]
%\centering
%\includegraphics[width=2.75in]{in_progress.eps}
%\caption{DTLS Handshake}
%\label{fig:dtls}
%\end{figure}

Implementation of an OpenSSL DTLS filter was non-trivial, as documentation is
sparse providing the possibility for varied approaches.  Traditionally, DTLS
uses the DGRAM (datagram) BIO (I/O abstraction) layer, which provides a reliable
UDP layer.  Because we need a filter, so that we can do both EtE and PtP traffic,
we used one memory BIO  for incoming traffic and another for outgoing traffic.
Memory BIOs provide pipes using RAM: data written to the BIO can then be read
in a first in, first out ordering.  Incoming messages written to or outgoing
messages read from the DTLS read or write BIOs, respectively, are 
either encrypted data packets or handshake control messages.  Sending and 
receiving clear text messages occur at the DTLS SSL object layer.  The pathway
for sending a clear text packet begins with the user performing an SSL\_write
operation, retrieving the encrypted data by performing a BIO\_read on the write
BIO, and sending the data over the network.  At the remote end, the packet is
passed to the SSL state machine by performing a BIO\_write on the incoming BIO
followed by a SSL\_read; the result will be the original clear text message.
This process also needs to handle control messages; we provide clear context in
Figure~\ref{fig:dtls_filter}.  As an aside, OpenSSL supports a SSL filter
BIO, though it will not work for this purpose as BIOs that are inserted are
expected to have two pipes, like a socket or two memory buffers.  Also the only
benefit of using the filter BIO would be that it manages auto-renegotiation,
which can be implemented in user code by monitoring time and received byte
count.  Other operations such as certificate verification and cookie generation
are handled by SSL callbacks, which hook into our security framework.

\begin{figure}[!h]
\centering
\includegraphics[width=2.75in]{dtls_filter.eps}
\caption{The DTLS filter.}
%  To send a secure message, execute SSL\_write and
%retrieve the encrypted packet at the WRITE BIO via a BIO\_read.  To verify
%and decrypt a packet, execute BIO\_write on the READ BIO and retrieve the
%packet via SSL\_read.  When SSL\_write or SSL\_read return the error WANT\_READ.
%This means that either it is waiting for a control message or one is available
%at the WRITE BIO.  If a message is retrieved from the WRITE BIO, it is a control
%message.  Because DTLS does not provide reliability when using the memory BIO,
%control messages should be sent using a reliable medium, such as a light-weight
%request/reply system.}
\label{fig:dtls_filter}
\end{figure}

% DAVID: do we need this discussion on CBCs? might be too narrow for this paper
% If space permits ...
%Since symmetric keys work on limited block size, they use modes of operation
%to encrypt or decrypt large sets of blocks.  Because DTLS uses an unreliable
%transfer mechanism, each message should be able to be decrypted without the use
%of previous messages.  As suggested in the DTLS paper, we used cipher-block
%chaning (CBC) with a new initialization vector (IV) for each message.  During
%analysis of our C\# implementation, we discovered that generating an IV was
%expensive but the initialization of an additional CBC state machine was even
%more.  To reduce these costs, the sender always uses the same CBC state machine
%and prepends the last cipher-block to the beginning of the next message.  Upon
%reception, a receiver compares the prepended message to a cache of CBC state
%machines stored by the current state, if there is a match, then the CBC state
%machine can be used, otherwise, if the packet is received out of order the
%receiver can start a new CBC state machine to decrypt the packet.
%Table~\ref{tab:cbc_issue} compares the overhead with the default implementation
%and with our revised version.  This issue does not appear in the OpenSSL
%implementation of CBC.

%\begin{table}[h]
%\setlength{\itemsep}{0pt}
%\setlength{\parskip}{0pt}
%\centering
%\begin{tabular}[c]{|m{1.5cm}||m{3cm}|m{3cm}|} \hline
%& Latency (ms) & Bandwidth (Mbit/s) \\ \hline\hline
%DTLS CBC & 0 & 0 \\ \hline
%Our CBC & 0 & 0 \\ \hline
%\end{tabular}
%\caption{CBC Issue -- In Progress.}
%\label{tab:cbc_issue}
%\end{table}

Due to the constraints in using OpenSSL, we have architected the system to
support multiple security frameworks; OpenSSL DTLS is one supported option, but
the system also supports a custom stack written in C\#.  To provide for
flexibility between the two approaches, we created a security overlord that
treats each approach like a filter.  Treating each implementation as a filter
allows incoming control and data messages to be pushed into the object and data
and control messages to be pulled out of the object.  While we believe OpenSSL's
DTLS to be a superior choice due to its prevalence and being well studied, it is
non-trivial to make available for all platforms.  Because our goal is to provide
a safe yet easy to use the overlay package, we leave the decision up to the user
which protocol to use.  We believe those interested in testing the system will
start with the .NET security stack and migrate to the OpenSSL DTLS stack.

An important component of security is the handling of revocations handled by our
broadcasting mechanism.  Though we call our broadcasting model bounded-broadcast
because it is capable of broadcasting to a subset of nodes, it is also capable
of broadcasting to the entire overlay.  A bounded broadcast uses the following
recursive algorithm:  Begin with node, $x$, triggering a broadcast message over
the region $[x, y]$.  $x$ has $F$ connections to nodes in the range $[x, y]$.
Denoting the $i^{th}$ such neighbor as $b_i$, the node $x$ sends a bounded
broadcast over a sub-range, $[b_i, b_{i+1})$, to $b_i$, except the final
neighbor.  Differently stated, $b_i$ is in charge of bounded-broadcasting 
in the sub-range $[b_i, b_{i+1})$. If there is no connection to a node in the
sub-range, the recursion has ended.  The final neighbor, ($b_F$), is responsible
for continuing the bounded broadcast from $[b_F, y]$.  When a node receives a
message to a range that contains its own address the message is delivered to
that node and then routed to others in that range.  Figure \ref{fig:tree} shows
how this bounded broadcast forms a local tree recursively.   The time required
for a bounded broadcast is $O(\log^2 N)$.  For security purposes, revoked peers
are not included in the set of neighbors during the recursion stage.

\begin{figure}[!h]
\centering
\includegraphics[width=2.5in]{tree}
\caption{Bounded Broadcast in range $[x, y]$}
\label{fig:tree}
\end{figure}

\subsection{Experimental Setup}
We use three quantitative methods to evaluate our proposed approach: network
modeling, simulation and deployments on an actual wide-area system,
PlanetLab~\cite{planetlab}.

\subsubsection{Network Modeling}
To model our system, we implemented an application that generates a structured
overlay with the usual dimensions found in our deployed steady state systems:
a system of size N with each peer having 3 near neighbors on both sides and
$O(.5\log N)$ shortcuts.  The modeler creates a fully connected system where
shortcuts are optimally chosen based upon their location in the node ID space
using a harmonic distribution.  Once the model has been fully generated, we use
the same routing code used in the deployed overlay software to model routing
behavior in terms of nodes visited, hops, and latency.  We employ
the MIT King data set~\cite{king_data} to determine the pairwise latency
between nodes.  The MIT King data set consists of latency between DNS servers
distributed globally on the Internet.  Since the MIT King data set only covers
1740 nodes, we randomly distributed the nodes in the address space placing
multiple nodes at the same ``physical'' location when necessary.  Security
was modeled by adding an additional of 3 round-trip latencies to all
connections, this models the behavior of the 6 message DTLS handshake used in
the deployed code base.

\subsubsection{Simulations}
Network modeling is limited to estimating values based upon empirical evidence
and only reuses a subset of the actual overlay code.  To allow complete
evaluation of our software stack, we have implemented a simulator using
event-driven time that faithfully reusing the entire overlay code base including
th routing, security, DHT, and connection state machines.  This allows us
to verify correct behavior in the system prior to testing out on real systems,
such as PlanetLab, as well as to perform experiments in a controlled
environment, which simplifies the evaluation while still retaining the effects
of a wide-are distributed system.  Like the network modeler, we also employed
the MIT King data set~\cite{king_data} for pairwise latency between peers.
To run the simulations, we employed Archer~\cite{archer}, which uses our P2P
VPN software to form a distributed and decentralized computing grid for
research into computer architecture.  Because the network modeler is very
light weight, it can model more than 100,000 peers using a single computer;
however, the simulator reuses the entire overlay software and can only simulate
around 1,000 peers.

\subsubsection{PlanetLab}
PlanetLab~\cite{planetlab} is a consortium of research institutes sharing
hundreds of globally distributed network and computing resources.  PlanetLab
provides a very interesting environment as there is constant unexpected churn
of machines due to the extreme load placed on the resources and system restarts.
Complementary to simulation, PlanetLab gives us a glimpse of what to expect
from the P2P software stack when used in an actual environment subject to higher
variance due to resource contention and churn.  Due to the time required and
complexities in working with PlanetLab, we limit the number of experiments we
used it for, focusing on the connection time to a private overlay.

\subsection{Connecting to the Private Overlay}
In this experiment, we seek to determine the overall time
it takes for a node to become connected to the public overlay, and then for a
subsequent node to become connected to the private overlay.  By connected, we
mean a node has a connection with the nodes whose IDs are closest in the ring (i.e., neighbors with IDs both smaller
than and larger than the node who is joining).  The results of this experiment
show the time it takes to connect to a public overlay, query the DHT for private overlay
information, and then connect to a private overlay with and without security.

To summarize the connection process, we first boot the public node.  Upon
becoming connected, the private node first inserts into the DHT its 
subring information using an automated lease extender.  Afterwards, we
start the private node and begin constantly querying the DHT key for information
from other nodes.  As soon as this is retrieved from the DHT, it is appended to the list of
nodes for the state machine to attempt connecting with.  Once the state machine
reaches a connected state, the test is terminated.  The reason for starting
the private node after the public node was due in part to earlier experiments.
We noticed that starting the public and private overlays at the same time took
longer due to the state machines in the private node using exponential time
back-offs of up to a minute when unable to retrieve the DHT keys.

For PlanetLab, we created several overlays with random distribution of private
nodes.  We start from a base network of
600 nodes on PlanetLab then had each node randomly decide to join the private
overlay in order to obtain private overlays consisting of 5 to 600 members.  We
crawled the network to verify the amount of private overlay nodes.  Then we began
the experiment by connecting to the ring from the same network location 100 times
using a different node ID each time, causing the node to join different peers and
create an distribution of connection times. During this process, we measured the time it
took for the public node and private nodes to become connected.  To ensure that
the PlanetLab public overlay was fully connected, we waited an hour prior to starting the
experiments to provide enough time for it to reach steady state. This is a conservative
value, in our experience with overlays we run on PlanetLab, pools of this size form a complete
ring in the order of minutes.

For Simulation, we followed similar steps though we were able to tighten the
exact amount of peers in both the public and private overlays.  We began with
a pool of 700 public nodes and 2 to 300 members in the private overlay.  We
then waited for the overlays to become fully connected, whereupon we waited
60 simulated minutes to ensure that the system was at steady state, i.e.,
trimming unnecessary connections and having a steady state machine.  At which
point, we added an additional public node with a matching private node.  We
took time snapshots of how long they took to become connected.

For the modeler, we repeated the steps done for the simulation, though
we were able to evaluate the timing of up to 100,000 nodes, so we performed
evaluations to compare with the PlanetLab and Simulation results as well as
much larger network sizes~\ref{fig:single_join_mod}.  For timing, we reviewed
the typical connection steps when connecting to the public overlay, querying
the DHT, and then connecting to the private overlay using this process as the
basis for our evaluation.

\begin{figure}[h]
\centering
\includegraphics[width=3.25in]{single_join.eps}
\caption{The time it takes for a single node joining a public overlay and then
a private overlay. Since the public overlay size is the same in all tests, we
averaged all results together for the individual evaluations.  The format for
the legend is defined using the following convention: EnvironmentOverlay,
where the environment is PlanetLab, Simulator, or (Network) Modeler and
overlay is Base for public overlay, No for no security private overlay, and
Sec for security enabled private overlay.  ModBase is network modeler
Public overlay connection time.  SimSec is simulator security enabled private
overlay.}
\label{fig:single_join}
\end{figure}


\begin{figure}[h]
\centering
\includegraphics[width=3.25in]{single_join_mod.eps}
\caption{The time it takes for a single node joining a public overlay and then
a private overlay. The legend consists of number[s], where the number
represents the number of peers in the public overlay and the optional ``s''
specifies whether the private overlay has security enabled.}
\label{fig:single_join_mod}
\end{figure}

Our results, Figures~\ref{fig:single_join},~\ref{fig:single_join_mod} are well
correlated with near identical slopes.  In all cases the time to become
connected with the private overlay remains reasonable and scales logarithmically
as network size grows.  Connection times differ amongst the set, because
the Simulator has let all the state machines waiting at maximum delay due to
the lack of churn in the system, PlanetLab has limited overhead due to this
delay, while the Network Modeler does not worry about state machine state,
churn, nor bad connection attempts.  An important result is that PtP security
does not significantly add to time to joining the overlays, most likely due
to the majority of the time being occupied by overlay routing.

\subsection{Instantaneous Pool Creation}
\label{mass_join}
In this experiment, we determine the amount of time required to bootstrap a
private overlay including their matching public overlay nodes using an existing
network.  We start with a network size of 200 public nodes and then add the
nodes who will become part of the private overlay.  Because PlanetLab is
difficult to control in terms of attempting to start 200 public nodes
simultaneously and ensuring that they do not restart mid-experiment, we ran
this experiment using the simulator.  Though we can state from previous
experience, that using PlanetLab, we typically see a network form within
minutes of the last host's overlay software starting.

\begin{figure}[h]
\centering
\includegraphics[width=3.25in]{mass_join.eps}
\caption{The time to form private overlay using a public overlay with 200 nodes
after simulataneously turning on various counts of private overlay nodes.}
\label{fig:big_join}
\end{figure}

In Figure~\ref{fig:big_join}, we present our results with and without security
for various sized networks.  The results present a slightly different picture
than the previous experiment.  In this case, there is a slightly logarithmic
growth to the time it takes to complete an overlay.  As in the previous test,
the use of security has a small relative impact on the overall time to
form the ring.

\subsection{Measuring Bandwidth}
The previous simulation experiments were in fact ran during the same test, but
in order to ensure stability, we always wait 60 virtual minutes before proceeding
to the next step.  Reusing the simulation results changes no results and cuts
down on the most expensive part of the procedure, the bootstrap phase.  In this
section, we present the network bandwidth used by each process, see
Figure~\ref{fig:bandwidth}.

\begin{figure}[h]
\centering
\includegraphics[width=3.25in]{bandwidth.eps}
\caption{Bandwidth used in a systems with and with security during steady state
operations consisting of 200 public nodes and various sized paired public /
private nodes.  Those lines labeled ``static'' have DHT lists queried every 5
minutes whereas in ``dynamic'' queries are made using an exponential back-off
policy starting at 30 seconds up to a maximum of 60 minutes.  Note, bandwidth
is in bytes / second, a negligible amount of bandwidth on most DSL and Cable
Internet systems.}
\label{fig:bandwidth}
\end{figure}

As shown in Figure~\ref{fig:bandwidth}, when cmparing the querying of the DHT
using static and dynamic timers, the static timer's bandwidth is dominated by
DHT queries.  Since the system is at steady state, i.e., no new nodes in the
system, only a single DHT query is made using dynamic timers.  In both cases,
the time to form a complete ring as performed in Section~\ref{mass_join} is the
same. The dynamic timer causes bandwidth to grow slower than a logarithmic pace.
Given that the bandwidth used grows slowly, it appears that overlays in general
use a negligible amounts of bandwidth and that even using security does not
increase it significantly.

In regards to selecting a proper timeout, it can logically be surmised that
if an existing public and private overlay are going through heavy churn,
there will always be a base of nodes connected to each other.  If because the DHT
is currently fragmented, a new node forms a partitioned private overlay, the node
should eventually and quickly find out about the original overlay and reform
the split overlays.  A dynamic timeout puts the weight for fixing ring partitions
on the nodes that created them rather than the older more stable nodes.  Though
it would appear that ring partitions occur most frequently during massive joins,
which is solved by using both static and dynamic timeouts while querying.

\subsection{Evaluating Revocation Implementations}
\label{evaluation_revocation}
In Figures~\ref{fig:revocation_sim} and \ref{fig:revocation_mod}, we present
the time required and network traffic to perform a revocation using the simulator
and modeler, respectively.  To evaluate the cost, we estimate that the average
size of a revocation is 300 bytes, which includes information such as the user's
name, the group, time of revocation, and a signature from the CA's private key.

\begin{figure}[h]
\centering
\includegraphics[width=2.75in]{revocation_sim.eps}
\caption{Time required and bandwidth used during simulated DHT and broadcast
revocation.}
\label{fig:revocation_sim}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=2.75in]{revocation_mod.eps}
\caption{Time required and bytes used during a modeled DHT and broadcast
revocation.}
\label{fig:revocation_mod}
\end{figure}

The results seem to indicate that in terms of time, they scale well together,
though in network traffic the DHT scales significantly better.  The problem
with the DHT approach is that it is inefficient for truly malicious peers.
In the case of the DHT, if a peer is revoked, it can attempt to connect with
new peers who have do not know of this revocation, each peer will have to query
the DHT.  If this becomes the case, the DHT method will quickly become more
inefficient.  On the flip side, the broadcast cannot ensure that all nodes
receive the message, due to overlay network stability issues, peers may not
be included in the broadcast.  As such the best approach may be to store a
revocation in the DHT but notify all peers of a revocation via a broadcast.

An interesting result for the broadcast is that it scales linearly as the number
of peers in the overlay increases, as such, it is as efficient as it could
possibly be.  This happens because a message never repeats over the same PtP
connection.

%\subsection{Multiplexing Sockets}
%\label{pathing_evaluation}
%If systems were to start making heavy use of the private overlay model, the most
%straightforward and simple approach would be to have many sockets and threads to
%constantly read from them.  One option is to make a multisocket device and use
%select, but that requires a unique solution for each socket type.  As we
%discussed early, we proposed an approach whereby an abstracted transport could
%easily be multiplexed without the need for additional threads, sockets, and other
%resources.  We call this pathing and what we do is prepend each packet with a
%unique ID to differentiate the owner.  So while it may reduce system resource
%consumption it may increase network consumption, so we test it to determine both.
%We present CPU, memory, and network in Figure~\ref{fig:pathing_eval}.
%
%\begin{figure}[h]
%\centering
%\includegraphics[width=2.75in]{in_progress.eps}
%\caption{Pathing evaluation.}
%\label{fig:pathing_eval}
%\end{figure}
%
%Some concluding remarks.
%
\section{Conclusion}
\label{conclusions}
In this paper, we presented a novel architecture for deploying secure, private
overlays in constrained environments through the use of public overlays.
The public overlay at a minimum must provide a distributed data store,
like a DHT, so that peers of the private system can rendezvous with each other.
For constrained environments, we used NAT traversal techniques including STUN and
TURN with both private and public overlays to support the relaying of packets.
We evaluated the use of DTLS in our system and determined that security overhead
does not provide significant overhead during connection starting and idle periods.
%and, to deal with excessive amounts of
%sockets, we introduced the notion of pathing, which showed that system resource
%consumption can be reduced with negligible effect on network performance.  
Most
importantly, we presented how a group infrastructure can be used as a user-friendly
and intuitive mechanism to create and maintain private and secure overlays.  
For verification of usability, we show that the time to become connected to the
private overlay occurs in less than 30 seconds and that the bandwidth required 
from each peer while idling was insignificant, on the order of 100 bytes per
second.

At this point in time our platform still has a few drawbacks.  Users that
cannot host their own web servers on the Internet are unable to use the groups
mechanism, this could be solved by making a web site accessable via a VPN or
directly through the overlay.  For each overlay, a peer will use more
resources, to reduce this, peers could multiplex a single socket for multiple
overlays reducing the thread count and open socket count.  Also it is important
to note that the public overlay should implement decentralized security
techniques, otherwise access to the private overlay will be hampered.  For
future work, we envision applying this approach to social networks and to
establish multicast groups as done in~\cite{can}.
%\section*{Acknowledgment}

\bibliographystyle{IEEEtran}
\bibliography{icdcs10}
\suppressfloats

\end{document}
